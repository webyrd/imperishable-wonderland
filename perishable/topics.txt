# Major 'Arcs' (in the manga/anime sense)

The Most Beautiful Program Ever Written (extensions, including errors and angelic execution, delimited control/effect handlers, store-passing style, mutation, call-by-value vs. call-by-name vs. call-by-need s. call-by-push-value, etc.)

Build Your Own Barliman

300 Orders of Magnitude or Bust! (Based on a CPP'24 talk showing Monte Carlo simulation + reinforcement learning applied to automated theorem proving finding a proof in a search tree with a branching factor of 10, at a depth of 300, equivalent to finding a solution in a search space of 10^300 (or so it is claimed).  I want the equivalent, or better, for search in miniKanren, for the relational Scheme interpreter and other relational programs.)

A Course of Instruction in Programming Languages, Relational Style (interpreters, type checkers/inferencers, semantics, computability theory, proof checkers, automated theorem provers, compilers, etc., all explored from a relational point of view; think of ideas found in EoPL, TAPL, SICP, TLS, Sipser, Nilson and Nilson semantics book, <add your own programming languages textbook here>, relational style)


# Assorted topics (some of these may be promoted to Arcs, and moved above)

TODO go through all my repos, as well

TODO look at mk Workshop papers

Logic programming approaches of different expressive power, and with different semantics (especially regarding negation), termination guarantees, and complexity classes.  Explore the mk equivalents as well.
* Prolog
* Datalog
* Answer Set Programming

negation and all that
* negation as failure
* the Clark completion (spelling?)
* conda and condu
* the g-rule
* the problems
* stratified negation
* ASP notion of negation and stable model semantics
* explicit encoding of constructive negation by writing a `not-<fooo>` relation as a counterpoint to your "positive" `fooo` relation
* encoding negative information through the relational Scheme interpreter: failure to pattern match, `not` as a Scheme predicate, etc.  What is the power, expressiveness, complexity, etc.?  To what extent can staging the interpreter and other techniques reduce the overhead?

different ways to go from Scheme to miniKanren:
* hand-transformation
* compile
* Scheme interpeter in mk

different ways to implement miniKanren:
* abstract machine
* deep embedding
* shallow embedding
* interpreter
* compiler
* FPGA
* ASIC

macros and miniKanren:
* a basic intro to Scheme macros
* macros in context, including how to use macros effectively:
** how the macros in miniKanren work
** alternative interfaces to miniKanren
*** `defrel`
*** alternative `run` interfaces
** writing various test macros

how to debug miniKanren programs
* causes of divergence
* causes of failure
* causes of unexpected behavior
* standard 'gotchas'
* `run 1` vs. `run *`
* running a relation with all variables fresh

program transformations, from a relational perspective:
* transformations of relational programs
* transformations implemented relationally

What makes a program relational?  What does that mean?  How can you tell if a program is relational?

How to translate a Prolog program to miniKanren.  How to deal with the nasty bits of Prolog that aren't relational

How to deal with the nasty bits of a Scheme program you want to translate to miniKanren

How to take an academic CS/PL paper and translate the rules to miniKanren, and play with those rules

how to deal with scope and binding: environments, De Bruijn, locally nameless, combinatory logic, nominal unification/equivariant unification, HOAS, nominal sets, etc.

relational macro expander:
* fexprs
* hygienic Scheme macros

environment trimming; memory management for logic programming

reading and implementing judgements

propositional calculus
predicate calculus
monadic second-order logic
higher-order logic
higher-order unification
HH Formula, and in Lambda Prolog
implication and negation in Lambda Prolog

eigen variables
universal vs. existential quantification
nominal logic and quantification

parsing
* with derivatives
* PEG
* packrat
* DCG + tabling (and equivalence to packrat parsing)
* LALR
* parser combinators

defeasible logic
linear logic
linear logic multiset rewriting

fixed point semantics
stable model semantics

denotational semantics
operational semantics
axiomatic semantics

equational reasoning

laziness

function-logic programming

generators
Icon

constructive logic
intuitionistic logic
classical logic

mechanized meta-theory

heap/stack/registers

backjumping
CDCL
two-watched literal scheme
unit propagation
underconstraints
SAT
SMT
solver-oriented programming

presento vs. absento
tree automata

Robinson and unification
the resolution method

unification and lattices; Plotkin and Reynolds papers
finding fixpoints over lattices
lattice-oriented programming
LVars and LVish
abstract interpretation, datalog, etc.

segment variables and pattern matching/unification

matche

duals of unification

anti-unification

CLP(Tree)
=/=
absento
type constraints

typed miniKanren

correctness-preserving program transformations
representation independence
defunctionalization
CPS
trampolining
registerization

first-order miniKanren

Fizzbuzz, relational style

Metamagical Themas: Lisp, self-reps, quines, and viruses -- miniKanren style
self-rep explorations with Nada Amin -- try to push further
self-modifying relational interpeter?

reflective tower of relational interpreters, in which one level can reach up and modify a level interpreting it

miniKanren quines -- mk `run` expressions that generate themselves -- try to generate using mk-in-mk (Michael Ballantyne has constructed these by hand)

visualizing the search space

modes
impure mk: project, conda, condu, copy_term, etc.

purity in Prolog -- more than just avoiding cut

various flavors of cut in Prolog: all the colors and mixes of colors; "soft-cut"; committed-choice non-determinism; Mercury; Oleg's explanation of what inspired `conda` vs `condu` in framenotes of TRS

true meta-circular Scheme interp
true meta-circular mk interp

mixing Scheme and mk code *relationally* through implementing Scheme and mk interpreters relationally in miniKanren: should be able to handle relationally (for example, perform synthesis) over mixtures of Scheme and mk as seen in TRS1, for example

handling fully relationally higher-order miniKanren relations such as `mapo`, through mk-in-mk

microKanren in Scheme in mk in Scheme to get relational behavior -- collapse/stage that!

can we synthesize a radiation-hardened quine?

combinatory logic in mk
synthesizing fixed point combinators
* the different approaches I've tried

Quines, twines, thrines
absento trick for twines
Quine relay
self-reps
Kleene's Recursion theorems
Omega and Y and U combinators
Omega as small-step Quine

vicious circles
non-well-founded set theory
coinductive logic programming, tabling, streams, etc.
rational infinite trees, Prolog II, etc.

tabled logic programming and abstract interpretation

top-down vs. bottom-up evaluation

bi-directional search

magic sets

focused proof search

mk as theorem prover
reifying the proof tree
LeanTAP
LeanCOP
Matt's simple proof checker and the 2017 ICFP pearl

Fun with GEB
GEB MIU interpreter -- I think I have a GitHub repo on this, with a U of Utah student -- undecidability

relational automata -- tabling, e-graphs, VSA, etc. -- try to recapture decidability and the ideal complexity classes, when the problems are deciadable (or in a mode in which everything should be decidable)

revisit Oleg's proofs in the purely relational arithmetic FLOPS paper; alternative representation of these numerals; tree constraints, e-graphs, etc.  sharing, tabling, etc.?  Hilbert's 10th problem

Hindley-Milner type inference; `let` polymorphism -- how best to represent?  complexity classes; principal typing; have we ever solved these issues satisfactorily?

Oleg's higher-order relation fixed point trick for relational type inferencer

non-monotonic logics

temporal logics

Ivan Bratko book

abductive reasoning

inductive logic programming

synthesis using relational interpreter and the complexity of program traces (vs. length of the code); a short Scheme program might require more computation than a longer program, if the shorter program has a longer trace to reach success (due to the use of a recursive helper, for example); `reverse` using `append` is hard for Barliman to find, if I remember correctly

Barliman optimizations

look at the screenshots of Barliman examples; also, the Clojure/conj talk I gave with Greg in Austin

n-grams for synthesis

termination analysis of mk relations, based on decreasing measure on argument terms -- Petr Lozov's dissertation work

interesting SW and mk Workshop papers

type systems and termination
occurs check and self-application and termination

the issue with small-step, multi-pass compilers, etc. -- "breaking the wires"
fail fast

N ways to perform arithemetic relationally
* Oleg arithmetic
* Peano
* CLP(FD)
* CLP(Z)
* CLP(SMT)
* delayed goals

tree automata
e-graphs
version space algebras

program synthesis -- try implementing various synthesis algorithms

search
* Oleg search
* DFS/BFS/IDDFS
* A*
* neural-guided search
* MCTS
* MC simulation + RL
* minimize KL-divergence

bidirectional computing

reversible computing

deep encoding + shallow encoding of mk-in-mk: combine to get run* expressiveness with performance closer to that of shallow embeddings

abstracting abstract machines

tabling

implementing different logics

Idris/miniKanren Love Child

combining parser, type checker/inferencer, and interpeter -- deal with the conjunction problem

the problems in miniKanren and general-purpose relational programming
* conjunction
* negation
* general-purpose vs. specialized constraints
* composing constraints

LeanTAP and other ATPsx

case studies in making programs relational, and exploring the resulting relations

case studies in making miniKanren programs fast

porting miniKanren to other languages and runtimes

understanding and hacking the implementation of `faster-miniKanren`

a taxonomy of miniKanren-related languages

revisiting Kanren

revisiting `mirror` and the old skool Kanren examples

annotated bibliography of miniKanren-related literature

Fifth Generation Computing Project

Archaelogy into old logic and relational languages

alternate tech for building mk:
* ferns
* propagators
* Warren Abstract Machine

Prolog/Datalog/ASP
Lambda Prolog
Godel
Escher
Verse
Mercury
etc.

concatenative programming

constraint logic programming

Constraint Handling Rules

concurrent prolog

Larry Moss's 1# register language, relational style

normalization-by-evaluation, relational style

relational implementation of FORTH

mutually-recursive relational languages

the equivalent of Chris Okasaki's 'Purely Functional Data Structures', but for relational programming

difference lists
set constraints
unification over records

Chomsky hierarchy

angelic execution

exceptions
control effects
effect handlers
delimited continuations

fuzzing

program synthesis
property-based program synthesis

towers of interpreters
mk in mk
quasiquote quines in Scheme in Scheme in mk in Scheme, and staging to remove overhead
heterogenous towers
collapsing towers

staged evaluation
partial deduction
super compilation (and the relational equivalent: conjunctive partial deduction (is this correct?))

extended Andorra model and conjunction

should `run*` use DFS?
