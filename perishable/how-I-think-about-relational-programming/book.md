% How I Think About Relational Programming
% William E. Byrd
% March 27, 2024

Copyright 2024 by William E. Byrd

This work is licensed under a [Creative Commons Attribution 4.0 International License](http://creativecommons.org/licenses/by/4.0/). (CC BY 4.0) 

# What is this book?

An attempt to describe some of my mental models for thinking about relational programming, especially in the context of miniKanren and its variants.

# Why this book?

The topic of how an experienced relational programmer/miniKanren programmer and researcher thinks about the relational paradigm seems to me to be worthy of its own short book, especially since discussion of the mental models I have developed over time, or that I have learned from others, feels different in character than a book or paper on the techniques of relational programming, or the features of miniKanren, or what-have-you.

# The writing philosophy behind this book

I'd like to keep the book short, and focused on mental models.

# Who is the audience for this book?

Anyone interested in a higher-level conceptual understanding of miniKanren and relational programming.

# Introduction --- How I think about relational programming

[TODO]

# Table metaphor for mk/relational programming.

[TODO]

# Logic programming vs. constraint programming vs. constraint logic programming vs. functional programming vs. functional logic programming vs. relational programming.

# How to think about what a `run` means, how to interpret the answers produced, etc.

[TODO]

# A modern view of unification in logic programming.

[TODO]

# Is relational programming better done in Prolog?

[TODO]

# Types and relational programming?

[TODO]

# How to think about `==` and `=/=`.

[TODO]

# Confusion people have with `=/=`.

[TODO]

# How to think about `absento`.

[TODO]

# Confusion people have about `absento`.

# Why program relationally?

[TODO]

# Purity --- friend or foe?

[TODO]

# Constraints and consistency/inconsistency + many worlds interpretation---OS process metaphor.

[TODO]

# Dan Friedman -- search strategy as an OS scheduling independent processes; complete search means that processes that don't diverge will run to completion, given enough time and memory.

[TODO]

# properties/desiderata of `run`, mk goals, etc.

[program slicing in that online Prolog book]

# When to design and implement a new constraint

[TODO]

# Performance

[TODO]

# Data representation

[TODO]

# Laziness

[TODO]

# Motivation for mk constraints.

[TODO]

# Connection with SQL, etc.

[`Simply Logical` -- very nice and readable book on logic programming with the SQL analogies in the last few chapter]
